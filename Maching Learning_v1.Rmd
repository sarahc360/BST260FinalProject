---
title: "Machine Learning"
output: html_document
---

Overview: using regression trees to predict (1) unpaid work and (2) female share of manager positions from OECD Data

##### Data pull from OECD data base

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(tidyverse)
library(tree)
library(MASS)
library(caret)
library(stringr)

ALLCOUNTRY <- read.csv("data1.csv")

ALLCOUNTRY <- ALLCOUNTRY %>% 
  dplyr::select(Country, IND, Indicator, Sex, Age.Group, Time, Value, Unit, Flags)

# Select specific variables and filter in only OECD countries
OECD_label <- c("Australia", "Austria", "Belgium", "Canada", "Chile", "Colombia", "Costa Rica", "Czech Republic", "Denmark", "Estonia", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Israel", "Italy", "Japan", "Korea", "Latvia", "Lithuania", "Luxembourg", "Mexico", "Netherlands", "New Zealand", "Norway", "Poland", "Portugal", "Slovak Republic", "Slovenia", "Spain", "Sweden", "Switzerland", "Turkey", "United Kingdom", "United States")

t1 <- ALLCOUNTRY %>% 
  dplyr::select(Country, IND, Indicator, Sex, Age.Group, Time, Value, Unit, Flags) %>%
  filter (Country %in% OECD_label)
```

### Section II
##### Building trees to predict unpid work

##### Data wrangling to organize data frame with 2018 data and latest data

```{r}
# Time variable was isolated only to 2018 for most variables as that is the most recent year with the most complete data, and combined with "latest year" time point as that was the only year with data in time in work

model_years <- c("2018")
model_age <- c("Total")

t1_tidy <- t1 %>% filter(Age.Group %in% model_age,
                           Time %in% model_years) 

## create columns for each indicator and input with value from cleaned data
kf_tidy_data <- t1_tidy %>% dplyr::select(Country, Sex, Indicator, Value) %>% 
  spread(Indicator, Value)

time_indicators <- c("Time spent in unpaid work, by sex","Time spent in paid work, by sex","Time spent in total work, by sex")

t1_tidy1 <- t1 %>% filter(Indicator %in% time_indicators)

kf_tidy_data1 <- t1_tidy1 %>% dplyr::select(Country, Sex, Indicator, Value) %>% 
  spread(Indicator, Value) 

kf_joined_data <- left_join(kf_tidy_data, kf_tidy_data1, by=c("Country","Sex")) %>%
  rename(female_boards = "Female share of seats on boards of the largest publicly listed companies",
         labour = "Labour force participation rate, by sex and age group ",
         maternity = "Length of maternity leave",
         parental = "Length of parental leave with job protection",
         involuntary_PT = "Share of employed in involuntary part-time employment, by sex and age group",
         part_time = "Share of employed in part-time employment, by sex and age group",
         employed_managers = "Share of employed who are managers, by sex",
         agriculture = "Share of employed working in agriculture, by sex",
         industry = "Share of employed working in industry, by sex",
         services = "Share of employed working in services, by sex",
         female_managers = "Share of female managers",
         paid_leave = "Total length of paid maternity and parental leave",
         unpaid_time = "Time spent in unpaid work, by sex",
         paid_time = "Time spent in paid work, by sex",
         total_time = "Time spent in total work, by sex") %>%
  filter(!is.na(unpaid_time))
```


##### Data wrangling to clean up data frame to be used for machine learning 

```{r}

# Create new variable for proportion of time spent in unpaid labor
kf_joined_data <- kf_joined_data %>% mutate(prop_unpaid = unpaid_time/total_time)

europe <- c("Austria","Belgium","Czech Republic","Denmark","Estonia","Finland","France", "Germany","Greece","Hungary","Iceland","Ireland", "Italy","Latvia","Lithuania","Luxembourg","Netherlands","Norway","Poland","Portugal","Slovak Republic", "Slovenia", "Spain", "Sweden", "Switzerland","United Kingdom") ## region 1
north_america <- c("Canada","United States","Costa Rica", "Mexico") ## region 2
south_america <- c("Chile","Colombia") ## region 3
middle_east <- c("Israel","Turkey") ## region 4
oceania <- c("Australia","New Zealand") ## region 5
asia <- c("Japan", "Korea") ## region 6

## Create data frame for model data, create region variable, and assign countries a region value
kf_model_data <- kf_joined_data %>% mutate(Region = ifelse(Country %in% europe, 1,
                                                  ifelse(Country %in% north_america, 2,
                                                  ifelse(Country %in% south_america,3,
                                                  ifelse(Country %in% middle_east, 4,
                                                  ifelse(Country %in% oceania, 5,
                                                  ifelse(Country %in% asia, 6, NA)))))))

## Code sex as a binary variable
kf_model_data <- kf_model_data %>% mutate(Sex = factor(Sex, levels=c("Men","Women"), labels=c("0","1")))

## Code region as a factor
kf_model_data <- kf_model_data %>% mutate(Region = factor(Region))
```


##### Regression tree train and test sets to predict PROPORTION of unpaid work among total work

```{r,message=FALSE, warning=FALSE}
library(tree)
library(MASS)
library(caret)

## set up training and test sets
set.seed(1)
unpaid_index_train = createDataPartition(y = kf_model_data$prop_unpaid,
                                  times = 1, p = 0.5, list = FALSE)
unpaid_train_set = slice(kf_model_data, unpaid_index_train)
unpaid_test_set = slice(kf_model_data, -unpaid_index_train)
```


##### Using TREE function to predict Proportion of Total Work Time that is Unpaid

```{r}
## make regression tree using tree predicting proportion of unpaid time using variables with the fewest NAs

##use predictors that do not have NAs
set.seed(1)

fit_tree1 <- tree(prop_unpaid ~ Region + Sex + labour + employed_managers + part_time, data = unpaid_train_set)
fit_tree1
summary(fit_tree1)

plot(fit_tree1, type="uniform")
text(fit_tree1, pretty = 0, cex = 1)

## calculate proportion of unpaid time predictions in test set
preds_tree1 <- predict(fit_tree1, newdata = unpaid_test_set)
summary(preds_tree1)
mean((preds_tree1 - unpaid_test_set$prop_unpaid)^2)

## look at reasonable tree depth for given dataset
set.seed(1)
cv_data <- cv.tree(fit_tree1)
plot(cv_data$size, cv_data$dev, type = "b")

```

##### Using RPART function to predict Proportion of Total Work Time that is Unpaid

```{r, message=FALSE, warning=FALSE}
## make regression tree using rpart
library(rpart)
library(rpart.plot)

set.seed(1)

fit_rpart1 <- rpart(prop_unpaid ~ Region + Sex + labour + employed_managers + part_time, data = unpaid_train_set)
summary(fit_rpart1)

rpart.plot(fit_rpart1, digits=4)

plotcp(fit_rpart1)
min_cp = fit_rpart1$cptable[which.min(fit_rpart1$cptable[,"xerror"]),"CP"]
min_cp

p <- prune(fit_rpart1, cp = 0.08)
rpart.plot(p, digits = 4)
```


##### Regression tree train and test sets to predict total MINUTES of unpaid work

```{r,message=FALSE, warning=FALSE}
## set up training and test sets
set.seed(1)
minutes_index_train = createDataPartition(y = kf_model_data$unpaid_time,
                                  times = 1, p = 0.5, list = FALSE)
minutes_train_set = slice(kf_model_data, minutes_index_train)
minutes_test_set = slice(kf_model_data, -minutes_index_train)
```


#### Using TREE to predict unpaid time in MINUTES

```{r}
## make regression tree using tree predicting minutes unpaid time

set.seed(1)

minutes_fit_tree <- minutes_train_set %>% tree(unpaid_time ~ Region + Sex + labour + employed_managers + part_time, data =., model=T)
minutes_fit_tree
summary(minutes_fit_tree)

plot(minutes_fit_tree, type="uniform")
text(minutes_fit_tree, pretty = 0, cex = 1)

## calculate unpaid time predictions in test set
preds_minutes_tree <- predict(minutes_fit_tree, newdata = minutes_test_set)
summary(preds_minutes_tree)
mean((preds_minutes_tree - minutes_test_set$unpaid_time)^2)

## find ideal number of nodes
minutes_data <- cv.tree(minutes_fit_tree)
plot(minutes_data$size, minutes_data$dev, type = "b")

## prune to 2 nodes
prune_minutes = prune.tree(minutes_fit_tree, best = 2)

## find test set estimates with pruned tree
preds_prune <- predict(prune_minutes, newdata = minutes_test_set)
summary(preds_prune)
mean((preds_prune - minutes_test_set$unpaid_time)^2)
```


##### Using TREE to predict total MINUTES of unpaid work, without sex as predictor

```{r}
## make regression tree using tree predicting minutes unpaid time

set.seed(1)

all_fit_tree <- tree(unpaid_time ~ Region + labour + employed_managers + part_time, data = minutes_train_set)
all_fit_tree
summary(all_fit_tree)

plot(all_fit_tree, type="uniform")
text(all_fit_tree, pretty = 0, cex = 1)

## calculate unpaid time predictions in test set
preds_all <- predict(all_fit_tree, newdata = minutes_test_set)
summary(preds_all)
mean((preds_all - minutes_test_set$unpaid_time)^2)

## find ideal number of nodes
minutes_all <- cv.tree(all_fit_tree)
plot(minutes_all$size, minutes_all$dev, type = "b")
```


##### Using rpart to predict total MINUTES of unpaid work, without sex as predictor

```{r}
##using rpart
minutes_fit_rpart <- rpart(unpaid_time ~ Region + labour + employed_managers + part_time, data = minutes_train_set)
summary(minutes_fit_rpart)

## rpart plot
rpart.plot(minutes_fit_rpart, digits=4)

## find cp for rplot
plotcp(minutes_fit_rpart)
min_cp = minutes_fit_rpart$cptable[which.min(minutes_fit_rpart$cptable[,"xerror"]),"CP"]
min_cp

## prune rpart tree
p1 <- prune(minutes_fit_rpart, cp = 0.14)
rpart.plot(p1, digits = 4)

## calculate unpaid time predictions in test set
preds_minutes_rpart <- predict(minutes_fit_rpart, newdata = minutes_test_set)
summary(preds_minutes_rpart)
mean((preds_minutes_rpart - minutes_test_set$unpaid_time)^2)

## calculate unpaid time predictions with pruned tree
preds_prune_rpart <- predict(p1, newdata = minutes_test_set)
summary(preds_prune_rpart)
mean((preds_prune_rpart - minutes_test_set$unpaid_time)^2)
```


### Section II:
###### Building regression trees for female share of managers

##### Data wrangling to organize data frame with years where % of managers who are females are available and create data set for modeling

```{r}
#create list for the years where female share of managers is available
managers_years <- c("2011","2012","2013","2014","2015","2016","2017","2018")

## Coding for regions
europe <- c("Austria","Belgium","Czech Republic","Denmark","Estonia","Finland","France", "Germany","Greece","Hungary","Iceland","Ireland", "Italy","Latvia","Lithuania","Luxembourg","Netherlands","Norway","Poland","Portugal","Slovak Republic", "Slovenia", "Spain", "Sweden", "Switzerland","United Kingdom") ## region 1
north_america <- c("Canada","United States","Costa Rica", "Mexico") ## region 2
south_america <- c("Chile","Colombia") ## region 3
middle_east <- c("Israel","Turkey") ## region 4
oceania <- c("Australia","New Zealand") ## region 5
asia <- c("Japan", "Korea") ## region 6

t1_female <- t1 %>% filter(Sex=="Women",
                           Age.Group=="Total",
                           Time %in% managers_years) 

##Ceate region variable, and assign countries a region value
t1_female <- t1_female %>% mutate(Region = ifelse(Country %in% europe, 1,
                                                  ifelse(Country %in% north_america, 2,
                                                  ifelse(Country %in% south_america,3,
                                                  ifelse(Country %in% middle_east, 4,
                                                  ifelse(Country %in% oceania, 5,
                                                  ifelse(Country %in% asia, 6, NA)))))))

## create columns for each indicator and input with value from cleaned data
kf_manager_data <- t1_female %>% dplyr::select(Country, Time, Sex, Indicator, Value, Region) %>% 
  spread(Indicator, Value) 

## Note: female_managers = female share of employment in managerial positions (%)
## Note: employed_managers = share of employed who are managers (%)
kf_manager_data <-kf_manager_data %>% rename(female_parliaments = "Female share of seats in national parliaments",
                                        female_boards = "Female share of seats on boards of the largest publicly listed companies",
                                        labour = "Labour force participation rate, by sex and age group ",
                                        maternity = "Length of maternity leave",
                                        parental = "Length of parental leave with job protection",
                                        involuntary_PT = "Share of employed in involuntary part-time employment, by sex and age group",
                                        part_time = "Share of employed in part-time employment, by sex and age group",
                                        employed_managers = "Share of employed who are managers, by sex",
                                        agriculture = "Share of employed working in agriculture, by sex",
                                        industry = "Share of employed working in industry, by sex",
                                        services = "Share of employed working in services, by sex",
                                        female_managers = "Share of female managers",
                                        paid_leave = "Total length of paid maternity and parental leave")

## remove all NAs from set, make time numeric
kf_manager_data <- kf_manager_data %>% na.omit() %>% 
  mutate(Time = as.numeric(Time))
```


###### Using TREE to predict female share in managers

```{r}
## set up training and test sets
set.seed(1)
managers_train = createDataPartition(y = kf_manager_data$female_managers,
                                  times = 1, p = 0.5, list = FALSE)
managers_train_set = slice(kf_manager_data, managers_train)
managers_test_set = slice(kf_manager_data, -managers_train)

## tree function
set.seed(1)

managers_tree <<- managers_train_set %>% 
  dplyr::select(!c(Country, Sex, parental, maternity)) %>%
  tree(female_managers ~ ., data =., model=T)
summary(managers_tree)

plot(managers_tree, type="uniform")
text(managers_tree, pretty = 0, cex = 1)

## calculate unpaid time predictions in test set
preds_managers <- predict(managers_tree, newdata = managers_test_set)
summary(preds_managers)
mean((preds_managers - managers_test_set$female_managers)^2)

## find ideal number of nodes
cv_managers <- cv.tree(managers_tree)
plot(cv_managers$size, cv_managers$dev, type = "b")
```


###### Using RPART to predict female share in managers

```{r}
##using rpart
managers_rpart <- managers_train_set %>% 
  dplyr::select(!c(Country, Sex, parental, maternity)) %>%
  rpart(female_managers ~ ., data =., model=T)
summary(managers_rpart)

## rpart plot
rpart.plot(managers_rpart, digits=4)

## find cp for rplot
plotcp(managers_rpart)
min_cp = managers_rpart$cptable[which.min(managers_rpart$cptable[,"xerror"]),"CP"]
min_cp

## prune rpart tree
managers_prune <- prune(managers_rpart, cp = 0.08)
rpart.plot(p1, digits = 4)

## calculate unpaid time predictions with test set (original tree)
preds_managers_rpart <- predict(managers_rpart, newdata = managers_test_set)
summary(preds_managers_rpart)
mean((preds_managers_rpart - managers_test_set$female_managers)^2)

## calculate unpaid time predictions with pruned tree
preds_managers_prune <- predict(managers_prune, newdata = managers_test_set)
summary(preds_managers_prune)
mean((preds_managers_prune - managers_test_set$female_managers)^2)
```

